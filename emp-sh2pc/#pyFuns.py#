import pandas as pd
import numpy as np
import math
import time
import json

def readData(fileName):
    df = pd.read_csv(fileName)   # [1271413 rows x 1 columns]
    df = df.to_numpy().flatten()
    df = df.tolist()
    return df
    
def nonNegative(value):
    return [round(v) if v>0 else 0 for v in value]

def DPTreeH(DPAllNodes, gap):
    height = int(math.log(gap, 2)) + 1 #the height of the tree
    if height == 1:
        return DPAllNodes[0]
    succ = DPAllNodes[0: gap].copy() #leaf nodes
    pt = 0+gap #the index of the first node in the second level
    for i in range(2, height+1, 1): #the level in the paper
        gap = int(gap/2) #the number of nodes in this level
        succ_new = [0 for i in range(gap)] #compute the sum of succ for each node in this level

        for j in range(gap): #
            succ_new[j] = succ[j*2] + succ[j*2+1]
      
        now = DPAllNodes[pt: pt + gap].copy() #the dp nodes for this level

        consist = [0 for i in range(gap)] #compute the #z[v] in paper
        a = (pow(2, i) - pow(2, i-1)) / (pow(2, i) - 1)
        b = (pow(2, i-1) - 1) / (pow(2, i) - 1)
        
        for j in range(gap):
            consist[j] =  a*now[j] + b*succ_new[j]

        pt = pt + gap #point to the first node of the next level 
        succ = consist # needed for next level 
    return consist[0]

def nodesSubtree(i):
    i += 1
    j = 1
    k = i
    rootLeft = i
    while (k % 2 == 0):
        rootLeft = i - 2**j + 1
        k = k / 2
        j += 1    
    return rootLeft - 1

def retrieveNodes(i):
    left = nodesSubtree(i)
    gap = i - left + 1
    height = int(math.log(gap, 2)) + 1
    for i in range(height):
        print("i-----", i)
        inteval = pow(2, i)
        print("inteval", inteval)
        for j in range(left, right+1, inteval):
            print(str(j) + "," + str(j+inteval-1))
            
# sort according to the DP hist of root 
def computeBin(data, markers, dp):
    counter = dp.copy()
    size = len(data)
    binNum = len(dp)
    bins = [binNum] * size
    # real records 
    for i in range(size):
        bin_num = data[i] - 1
        if markers[i] == 1:  
            if counter[bin_num] > 0:
                bins[i] = bin_num
                counter[bin_num] = counter[bin_num] - 1
    # dummy records 
    for i in range(size):
        if markers[i] == 2:
            for j in range(binNum):
                if bins[i] == binNum and counter[j] > 0 :
                    bins[i] = j
                    counter[j] = counter[j] - 1
    return bins

# sort according to the DP hist of root 
def computeBinJ(data, markers, sortDPd, j):
    counter = sortDPd
    size = len(data)
    bins = [1] * size
    # real records 
    for i in range(size):
        bin_num = data[i] - 1
        if markers[i] == 1 and bin_num == j and counter > 0:
            bins[i] = 0
            counter = counter - 1
    # dummy records 
    for i in range(size):
        if markers[i] == 2 and counter > 0:
            bins[i] = 0
            counter = counter - 1
            continue
    return bins



# using list comprehension + sum() + list slicing
# prefix sum list
def computePrefix(test_list):
    res = [sum(test_list[ : i + 1]) for i in range(len(test_list))]
    return res
    
def seperateD(dpMergedPrevious, dataMergedPrevious, d, numBin):
    vectFirst = [None] * numBin
    vectSecond = []
    intervals = len(dpMergedPrevious)
    # preprocess preefix --> cut last bin if no enough records 
    # preprocess prefixsum
    dpHistPrefixIntrevals = [None] * intervals
    for i in range(intervals):  # for each interval
        sizeInterval = len(dataMergedPrevious[i])
        dpMergedPrevious[i][numBin-1] = sizeInterval #?
        dpHistPrefix = [0] * (numBin+1) 
        for j in range(numBin):
            dpHistPrefix[j+1] = dpMergedPrevious[i][j]
        dpHistPrefixIntrevals[i] = dpHistPrefix
    for i in range(numBin): # for each bin 
        first = []
        for j in range(intervals):  # for each interval
            left = dpHistPrefixIntrevals[j][i+1] - d if (dpHistPrefixIntrevals[j][i] < dpHistPrefixIntrevals[j][i+1] - d) else dpHistPrefixIntrevals[j][i]
            begining = dataMergedPrevious[j][dpHistPrefixIntrevals[j][i]: left].copy()
            ending = dataMergedPrevious[j][left: dpHistPrefixIntrevals[j][i+1]].copy()
            first.extend(begining)  # the first n-d
            vectSecond.extend(ending)   # the last d 
        vectFirst[i] = first.copy()

    return (vectFirst, vectSecond)  

def seperateBin(sorted_data, sortDPdHist):
    numBin = len(sortDPdHist)
    seperatedData = [None]*numBin
    dpHistPrefix_tmp = computePrefix(sortDPdHist)
    dpHistPrefix_tmp[numBin-1] = len(sorted_data)  
    dpHistPrefix = [0]*(numBin+1)
    for j in range(numBin):
        dpHistPrefix[j+1] = dpHistPrefix_tmp[j]
    for j in range(numBin):
        seperatedData[j] = sorted_data[dpHistPrefix[j]: dpHistPrefix[j+1]].copy()

    return seperatedData 


# for each time unit, insert real and dummy records, and compute true histogram
def originalDataMarkerHists(treeorLeaf, T, numReal, num_Dummy, numBins, df):
    originalData = {}
    originalDummyMarkers = {}
    trueHists = [None] * T
    for i in range(T):
        if (treeorLeaf == "tree"):
            if (i%2 == 1):
                numDummy = 0
            else:
                numDummy = num_Dummy
        # for originalData
        records = [None] * (numReal+numDummy)
        records[0: numReal] = df[i*numReal: (i+1)*numReal].copy()
        records[numReal: numReal+numDummy] = [10] * numDummy #todo change mpc code
        originalData[i] = records
        # for originalDummyMarker
        DummyMarker = [None] * (numReal+numDummy)
        DummyMarker[0: numReal] = [1] * numReal
        DummyMarker[numReal: numReal+numDummy] = [2] * numDummy #todo change mpc code
        originalDummyMarkers[i] = DummyMarker
        # compute trueHists
        counts, bins = np.histogram(records, bins=np.arange(1,numBins+2)) #[1,2,3,4,5] -> 4bins
        trueHists[i] = counts 
 #   print(originalData)
 #   print(originalDummyMarkers)
 #   print(trueHists)
    return originalData, originalDummyMarkers, trueHists
    
    
def computeTrueRecords(dpHist, dpStore):
    binNum = len(dpHist)
    recordNum = len(dpStore) 
            
    dpHistPrefix_tmp = computePrefix(dpHist)
    dpHistPrefix_tmp[binNum-1] = recordNum  
    dpHistPrefix = [0]*(binNum+1)
    for j in range(binNum):
        dpHistPrefix[j+1] = dpHistPrefix_tmp[j]
    trueR = [0]*binNum
    for i in range(binNum):
        num = 0
        for j in range(dpHistPrefix[i], dpHistPrefix[i+1], 1):
            if ((dpStore[j]-1) == i): #dpStorePublic[j]: 1122334455
                num = num+1
        trueR[i] = num
    return trueR 

def computeDummyRecordsCache(cache):
    num = 0
    size = len(cache)
    for i in range(size):
        if cache[i] == 2:
            num = num+1
    return num 

def intervalRangeQ(i):  
    intervalss = []
    rightI = i
    while (rightI >= 0):
        rootLeftI = nodesSubtree(rightI)
        intervalRootDPI = str(rootLeftI) + ',' + str(rightI)
        intervalss.append(intervalRootDPI)
        rightI = rootLeftI - 1
    return intervalss



